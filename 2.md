핵심은 브라우저 확장으로 실제 화면을 캡처하고, code.to.design 변환 API와 피그마 플러그인 SDK로 캡처 결과를 완전 편집 가능한 레이어와 로컬 스타일로 재구성하는 3단 구성이라는 점이다. 이 조합이 URL 입력·캡처·.h2d 전송·Figma 복원까지 이어져 웹페이지를 시안처럼 거의 그대로 가져오게 만든다.[1][2][3][4][5]

### 구성 요소
- Figma 플러그인: URL을 넣어 페이지를 가져오고, 변환된 결과를 캔버스에 그리며 텍스트·컬러 스타일을 로컬 스타일로 만든다.[1]
- 브라우저 확장: 로그인 뒤 페이지 등 사적 화면을 직접 캡처하고 .h2d 파일로 저장하거나 플러그인으로 바로 전송한다.[2][1]
- code.to.design: HTML/CSS/JS를 받아 복사본 텍스트와 이미지·폰트 등 자산을 포함한 페이로드로 변환하고, SDK가 Figma에 그릴 수 있게 준비한다.[3][5]

### 동작 흐름(리버스 엔지니어링)
- URL 모드: 플러그인에 URL을 입력하면 서버측 code.to.design 변환 파이프라인이 HTML/CSS/JS를 처리해 Figma용 결과를 반환하고, 플러그인이 이를 프레임·레이어로 배치한다는 구성이 합리적이다.[3][1]
- 캡처 모드: 확장이 크롬 디버깅 기능 접근으로 “보이는 그대로”를 수집하고, 결과를 .h2d로 저장하거나 플러그인에 스트리밍하여 동일한 재구성이 이뤄진다.[4][2]
- 스타일링: 변환 결과를 기반으로 텍스트/컬러 로컬 스타일을 자동 생성해 이후 디자인에서 재사용 가능하게 한다.[1]
- 옵션화: 동일 페이지를 서로 다른 뷰포트·테마로 가져와 다양한 미디어쿼리 상태를 커버하도록 설계되어 있다.[1]

### 왜 정확도가 높은가
- 실제 브라우저 컨텍스트에서 캡처해 로그인 뒤 화면과 동적 렌더링을 그대로 반영한다.[1]
- 크롬 디버깅 기능 사용을 명시해 렌더된 상태와 매핑 정밀도를 높인다.[2]
- .h2d가 “재현에 필요한 모든 정보”를 담는 권장 포맷이라 재구성 손실을 줄인다.[6]
- 서버 변환은 HTML/CSS/JS와 텍스트·이미지·폰트를 통째로 처리하여 플러그인 SDK가 손쉽게 Figma에 그리도록 한다.[5][3]

### 동일한 아키텍처로 구현하기
- 캡처 계층: 크롬 확장으로 대상 페이지를 캡처하고, 로그인 상태 포함 페이지를 지원하며 결과를 전송/저장(.h2d 유사 포맷)하도록 한다.[4][2][1]
- 변환 계층: 서버에서 HTML/CSS/JS를 수신하여 텍스트·이미지·폰트 같은 자산을 번들링한 중간 표현으로 가공하고, Figma용 SDK가 소비할 스키마로 직렬화한다.[5][3]
- 플러그인 계층: Figma 플러그인이 변환 페이로드를 읽어 프레임·텍스트·이미지로 구성하고, 텍스트/컬러를 로컬 스타일로 자동 생성한다.[5][1]
- 모드/옵션: URL 가져오기, 로컬 .html/.zip/.h2d 임포트, 뷰포트·테마 선택을 제공해 다양한 입력과 미디어 조건을 다룬다.[6][1]

### 구현 포인트 체크리스트
- 브라우저 캡처는 크롬 디버깅 기능을 사용하고 결과를 .h2d 유사 포맷으로 저장/전송한다.[2][4]
- 서버 변환은 HTML/CSS/JS와 텍스트·이미지·폰트를 포함한 결과를 SDK 친화 스키마로 제공한다.[3][5]
- 플러그인은 로컬 텍스트/컬러 스타일을 자동 생성하고, URL·로컬 파일·확장 캡처 입력을 모두 처리한다.[6][1]
- 사용자 옵션으로 뷰포트/테마를 노출해 동일 URL의 다양한 상태를 임포트할 수 있게 한다.[1]

### 한계와 주의
- 외부 리소스가 누락된 단일 HTML은 임포트 실패 가능성이 있어 .h2d나 zip 사용이 권장된다.[6]
- 사적 페이지 임포트는 확장과 플러그인 연동 탭을 통해 수행해야 한다.[7]
- 팀 버전·플레이그라운드 등 배포 옵션이 분화되어 있어 요구사항에 맞는 버전을 선택해야 한다.[8][9]

html을 넣으면 우리 서버에서 렌더링해서 h2d 파일로 변환하고, 해당 h2d파일을 토대로 웹의 디자인 100%를 구현한다. 
