import { promises as fs } from 'fs';































import { GoogleGenerativeAI, type GenerativeModel } from '@google/generative-ai';































import { logger } from '../utils/logger';































import type { HTMLNodeSnapshot } from '../types/converter.types';































import type { FigmaNodeData, FigmaPaint } from '../types/figma.types';































import type { VisionAnalysis, VisionAnnotation, VisionSuggestion } from '../types/vision.types';































import { withTimeout, TimeoutError } from '../utils/async-utils';































import { getEnv } from '../config/env';































































const GEMINI_API_KEY = getEnv('GEMINI_API_KEY') ?? getEnv('GOOGLE_API_KEY');































const DEFAULT_MODEL = getEnv('GEMINI_MODEL') ?? 'gemini-2.5-flash';































const DEFAULT_VISION_TIMEOUT_MS = Number(getEnv('VISION_TIMEOUT_MS') ?? '4000');































const MAX_CHARS_PER_CHUNK = Number(getEnv('VISION_CHUNK_CHAR_LIMIT') ?? '6000');































const MAX_VISION_CHUNKS = Number(getEnv('VISION_MAX_CHUNKS') ?? '4');































































interface AnalyzeCaptureInput {































  screenshotPath?: string;































  rootSnapshot?: HTMLNodeSnapshot;































  nodes: FigmaNodeData[];































  promptExtras?: string;































}































































interface AnalyzeCaptureOptions {































  timeoutMs?: number;































  allowModel?: boolean;































}































































const VISION_RESPONSE_SCHEMA = {































  type: 'object',































  properties: {































    summary: { type: 'string' },































    annotations: {































      type: 'array',































      items: {































        type: 'object',































        properties: {































          target: {































            type: 'object',































            properties: {































              nodeId: { type: 'string', nullable: true },































              htmlTag: { type: 'string', nullable: true },































              bounds: {































                type: 'object',































                properties: {































                  x: { type: 'number' },































                  y: { type: 'number' },































                  width: { type: 'number' },































                  height: { type: 'number' },































                },































                required: ['x', 'y', 'width', 'height'],































                nullable: true,































              },































            },































            required: [],































          },































          suggestions: {































            type: 'array',































            items: {































              type: 'object',































              properties: {































                property: { type: 'string' },































                value: {},































                confidence: { type: 'number', nullable: true },































                summary: { type: 'string', nullable: true },































              },































              required: ['property', 'value'],































            },































          },































        },































        required: ['target', 'suggestions'],































      },































    },































    issues: {































      type: 'array',































      items: { type: 'string' },































      nullable: true,































    },































  },































  required: ['summary', 'annotations'],































} as const;































































let geminiClient: GoogleGenerativeAI | undefined;































let geminiModel: GenerativeModel | undefined;































































const getGeminiModel = (): GenerativeModel | undefined => {































  if (!GEMINI_API_KEY) {































    logger.info('Gemini vision disabled: API key not provided');































    return undefined;































  }































  if (!geminiClient) {































    geminiClient = new GoogleGenerativeAI(GEMINI_API_KEY);































  }































  if (!geminiModel) {































    logger.info('Initialized Gemini model', { 'model': DEFAULT_MODEL });































    geminiModel = geminiClient.getGenerativeModel({ model: DEFAULT_MODEL });































  }































  return geminiModel;































};































































const flattenSnapshots = (root?: HTMLNodeSnapshot): HTMLNodeSnapshot[] => {































  if (!root) return [];































  const nodes: HTMLNodeSnapshot[] = [];































  const queue: HTMLNodeSnapshot[] = [root];































  while (queue.length > 0) {































    const current = queue.shift();































    if (!current) continue;































    nodes.push(current);































    queue.unshift(...current.children);































  }































  return nodes;































};































































const cssColorToPaint = (value?: string): FigmaPaint | undefined => {































  if (!value) return undefined;































  const hexMatch = value.match(/^#([0-9a-f]{3}|[0-9a-f]{6}|[0-9a-f]{8})$/i);































  if (hexMatch) {































    const hex = hexMatch[1];































    const expand = (component: string) => (component.length === 1 ? component + component : component);































    const r = parseInt(expand(hex.slice(0, hex.length >= 6 ? 2 : 1)), 16) / 255;































    const g = parseInt(expand(hex.slice(hex.length >= 6 ? 2 : 1, hex.length >= 6 ? 4 : 2)), 16) / 255;































    const b = parseInt(expand(hex.slice(hex.length >= 6 ? 4 : 2, hex.length >= 6 ? 6 : 3)), 16) / 255;































    const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;































    return { type: 'SOLID', color: { r, g, b, a } };































  }































  const rgbMatch = value.match(/rgba?\(([^)]+)\)/i);































  if (rgbMatch) {































    const parts = rgbMatch[1].split(',').map((part) => part.trim());































    const [rRaw, gRaw, bRaw, aRaw] = parts;































    const toChannel = (component?: string) => {































      if (!component) return 0;































      return component.includes('%') ? parseFloat(component) / 100 : parseFloat(component) / 255;































    };































    return {































      type: 'SOLID',































      color: {































        r: toChannel(rRaw),































        g: toChannel(gRaw),































        b: toChannel(bRaw),































        a: aRaw !== undefined ? parseFloat(aRaw) : 1,































      },































    };































  }































  return undefined;































};































































const createSnapshotSummary = (root?: HTMLNodeSnapshot, limit = 15): string => {































  if (!root) return 'No DOM snapshot available';































  const lines: string[] = [];































  const stack: Array<{ node: HTMLNodeSnapshot; depth: number }> = [{ node: root, depth: 0 }];































  while (stack.length > 0 && lines.length < limit) {































    const { node, depth } = stack.shift()!;































    const indent = '  '.repeat(depth);































    const label = `${node.tagName}${node.classes.length ? `.${node.classes.slice(0, 2).join('.')}` : ''}`;































    lines.push(`${indent}- ${label} (w:${node.boundingBox.width.toFixed(1)} h:${node.boundingBox.height.toFixed(1)})`);































    node.children.forEach((child) => stack.push({ node: child, depth: depth + 1 }));































  }































  if (lines.length === limit) {































    lines.push('  ...');































  }































  return lines.join('\n');































};































































const summarizeSnapshotNodes = (root?: HTMLNodeSnapshot): string[] => {































  if (!root) return [];































  return flattenSnapshots(root).map((node) => {































    const keyStyles = [































      'display',































      'background-color',































      'color',































      'font-size',































      'font-weight',































      'text-align',































      'width',































      'height',































      'border-radius',































      'box-shadow',































    ]































      .map((styleKey) => {































        const value = node.styles[styleKey];































        return value ? `${styleKey}:${value}` : undefined;































      })































      .filter(Boolean)































      .join(';');































































    return `node:${node.id} tag:${node.tagName} classes:${node.classes.slice(0, 3).join('.') || 'none'} bbox:[${node.boundingBox.x.toFixed(1)},${node.boundingBox.y.toFixed(1)},${node.boundingBox.width.toFixed(1)},${node.boundingBox.height.toFixed(1)}] text:${node.textContent ?? '?'} styles:${keyStyles}`;































  });































};































































const summarizeFigmaNodes = (nodes: FigmaNodeData[]): string[] => {































  return nodes.map((node) => {































    const fills = node.fills?.map((fill) => fill.type).join(',') ?? 'none';































    const textContent = node.text?.characters ? node.text.characters.slice(0, 80) : '?';































    return `figmaNode:${node.id} type:${node.type} tag:${node.meta?.htmlTag ?? 'unknown'} bbox:[${node.boundingBox.x},${node.boundingBox.y},${node.boundingBox.width},${node.boundingBox.height}] layout:${node.layoutMode ?? 'NONE'} fills:${fills} text:${textContent}`;































  });































};































































const buildChunks = (lines: string[], maxChars: number, maxChunks: number): string[] => {































  const chunks: string[] = [];































  let current = '';































































  lines.forEach((line) => {































    if (line.length > maxChars) {































      for (let i = 0; i < line.length && chunks.length < maxChunks; i += maxChars) {































        chunks.push(line.slice(i, i + maxChars));































      }































      current = '';































      return;































    }































































    if ((current + line + '\n').length > maxChars) {































      if (current.trim().length > 0 && chunks.length < maxChunks) {































        chunks.push(current.trim());































      }































      current = '';































    }































































    current += `${line}\n`;































  });































































  if (current.trim().length > 0 && chunks.length < maxChunks) {































    chunks.push(current.trim());































  }































































  return chunks.slice(0, maxChunks);































};































































const simulateVisionInsights = (input: AnalyzeCaptureInput): VisionAnalysis => {































  const nodes = flattenSnapshots(input.rootSnapshot);































  const annotations: VisionAnnotation[] = [];































































  const heroCandidate = nodes































    .filter((node) => node.tagName !== 'body' && node.boundingBox.width >= 600 && node.boundingBox.height >= 200)































    .sort((a, b) => b.boundingBox.width * b.boundingBox.height - a.boundingBox.width * a.boundingBox.height)[0];































































  if (heroCandidate) {































    const direction = heroCandidate.styles['flex-direction']?.includes('column') ? 'VERTICAL' : 'HORIZONTAL';































    annotations.push({































      target: { nodeId: heroCandidate.id, htmlTag: heroCandidate.tagName },































      suggestions: [































        {































          property: 'layoutMode',































          value: direction,































          confidence: 0.55,































          summary: 'Large hero block likely uses auto layout in the primary direction',































        },































      ],































    });































  }































































  const buttonCandidate = nodes.find((node) => {































    const isButton = node.tagName === 'button' || node.classes.some((cls) => /btn|button/i.test(cls));































    const hasRounded = parseFloat(node.styles['border-radius'] ?? '0') >= 16;































    return isButton || hasRounded;































  });































































  if (buttonCandidate) {































    const fill = cssColorToPaint(buttonCandidate.styles['background-color']);































    const suggestionList: VisionSuggestion[] = [































      {































        property: 'cornerRadius',































        value: 24,































        confidence: 0.6,































        summary: 'CTA button typically has pill-shaped radius',































      },































    ];































    if (fill) {































      suggestionList.push({































        property: 'fills',































        value: [fill],































        confidence: 0.5,































        summary: 'Preserve CTA button fill color detected from screenshot',































      });































    }































    annotations.push({































      target: { nodeId: buttonCandidate.id, htmlTag: buttonCandidate.tagName },































      suggestions: suggestionList,































    });































  }































































  if (annotations.length === 0 && nodes.length > 0) {































    const first = nodes[0];































    annotations.push({































      target: { nodeId: first.id, htmlTag: first.tagName },































      suggestions: [































        {































          property: 'layoutMode',































          value: 'VERTICAL',































          confidence: 0.4,































          summary: 'Default heuristic layout applied due to limited signals',































        },































      ],































    });































  }































































  const summaryParts = [































    'Heuristic vision fallback applied',































    heroCandidate ? 'Identified probable hero container and enforced auto layout direction.' : 'No distinct hero container detected.',































    buttonCandidate ? 'CTA button styling preserved from DOM heuristics.' : 'CTA button not confidently identified.',































  ];































































  return {































    source: 'heuristic',































    summary: summaryParts.join(' '),































    annotations,































    issues: input.screenshotPath ? undefined : ['Screenshot unavailable; relied on DOM heuristics only.'],































  };































};































































const parseVisionJson = (raw: string): { summary?: string; annotations?: VisionAnnotation[]; issues?: string[] } | undefined => {































  try {































    return JSON.parse(raw);































  } catch (error) {































    logger.warn('Failed to parse vision JSON', { error, raw });































    return undefined;































  }































};































































const callGeminiForChunks = async (































  chunks: string[],































  screenshotBase64: string | undefined,































  timeoutMs: number,































): Promise<VisionAnalysis | undefined> => {































  const model = getGeminiModel();































  if (!model) return undefined;































































  const aggregatedAnnotations: VisionAnnotation[] = [];































  const summaries: string[] = [];































  const issues: string[] = [];































































  for (let index = 0; index < chunks.length; index += 1) {































    const chunk = chunks[index];































    const chunkPreview = chunk.length > 300 ? chunk.slice(0, 300) + '...' : chunk;
    logger.info('Gemini vision chunk request', {































      chunkIndex: index + 1,































      chunkCount: chunks.length,































      chunkChars: chunk.length,































      includeScreenshot: Boolean(screenshotBase64),































    });































































    const parts: any[] = [































      {































        text: `Chunk ${index + 1}/${chunks.length}. Analyse these nodes from an HTML to Figma conversion and return structured corrections.`,































      },































      {































        text: chunk,































      },































    ];































































    if (screenshotBase64) {































      parts.push({































        inlineData: {































          data: screenshotBase64,































          mimeType: 'image/png',































        },































      });































    }































































    const request = {































      contents: [































        {































          role: 'user',































          parts,































        },































      ],































      generationConfig: {































        responseMimeType: 'application/json',































        responseSchema: VISION_RESPONSE_SCHEMA,































      },































    };































































    try {































      const result: any = await withTimeout(































        model.generateContent(request as any),































        timeoutMs,































        'gemini-vision-chunk',































      );































      const rawText = result?.response?.text?.() ?? result?.response?.candidates?.[0]?.content?.parts?.[0]?.text;































      if (!rawText) {































        issues.push(`Chunk ${index + 1}: empty model response`);































        logger.warn('Gemini vision chunk returned empty response', { chunkIndex: index + 1 });































        continue;































      }































      const preview = rawText.length > 400 ? rawText.slice(0, 400) + '...' : rawText;































      logger.info('Gemini vision chunk raw preview', { chunkIndex: index + 1, preview });































      const parsed = parseVisionJson(rawText);































      if (!parsed) {































        issues.push(`Chunk ${index + 1}: invalid JSON`);































        logger.warn('Gemini vision chunk produced invalid JSON', { chunkIndex: index + 1, preview });































        continue;































      }































































      logger.info('Gemini vision chunk success', {































        chunkIndex: index + 1,































        annotationCount: parsed.annotations?.length ?? 0,































        summaryPreview: parsed.summary ? parsed.summary.slice(0, 120) : null,































      });































































      if (parsed.summary) {































        summaries.push(parsed.summary);































      }































      if (parsed.annotations?.length) {































        aggregatedAnnotations.push(...parsed.annotations);































      }































      if (parsed.issues?.length) {































        issues.push(...parsed.issues);































      }































    } catch (error) {































      if (error instanceof TimeoutError) {































        issues.push(`Chunk ${index + 1}: timed out after ${timeoutMs}ms`);































        logger.warn('Gemini vision chunk timed out', { chunkIndex: index + 1, timeoutMs });































      } else {































        issues.push(`Chunk ${index + 1}: ${(error as Error).message ?? 'vision error'}`);















        logger.warn('Gemini vision chunk failed', { chunkIndex: index + 1, error: (error as Error).message ?? 'vision error' });































      }































    }































  }































































  if (aggregatedAnnotations.length === 0 && summaries.length === 0) {







    logger.warn('Gemini vision produced no actionable output', { chunkCount: chunks.length, issues });































    return undefined;































  }































































  return {































    source: 'ai',































    model: DEFAULT_MODEL,































    summary: summaries.join(' '),































    annotations: aggregatedAnnotations,































    issues: issues.length ? issues : undefined,































  };































};































































export const analyzeCapture = async (































  input: AnalyzeCaptureInput,































  options: AnalyzeCaptureOptions = {},































): Promise<VisionAnalysis> => {































  const allowModel = options.allowModel ?? true;































  const timeoutMs = options.timeoutMs ?? DEFAULT_VISION_TIMEOUT_MS;































































  if (allowModel && GEMINI_API_KEY) {































    const lines = input.rootSnapshot































      ? summarizeSnapshotNodes(input.rootSnapshot)































      : summarizeFigmaNodes(input.nodes);































































    const chunks = buildChunks(lines, MAX_CHARS_PER_CHUNK, MAX_VISION_CHUNKS);



    logger.info('Gemini vision chunk plan', { chunkCount: chunks.length, maxChars: MAX_CHARS_PER_CHUNK, maxChunks: MAX_VISION_CHUNKS, inputNodes: input.nodes.length, hasSnapshot: Boolean(input.rootSnapshot) });































































    if (chunks.length > 0) {































      try {































        const screenshotBase64 = input.screenshotPath































          ? (await fs.readFile(input.screenshotPath)).toString('base64')































          : undefined;































































        const vision = await callGeminiForChunks(chunks, screenshotBase64, timeoutMs);































        if (vision) {































          return vision;































        }































      } catch (error) {































        if (error instanceof TimeoutError) {































          logger.warn('Vision model timed out globally', { timeoutMs });































        } else {































          logger.warn('Vision model failed, using heuristic fallback', { error });































        }































      }































    } else {































      logger.warn('Gemini vision chunking produced no chunks; using heuristics', { chunkCount: chunks.length, hasSnapshot: Boolean(input.rootSnapshot), inputNodes: input.nodes.length });































    }































  }































































  return simulateVisionInsights(input);































};
































































